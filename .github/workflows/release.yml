name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write

env:
  ENVIRONMENT: PROD

jobs:
  # 1. Voraussetzung: Linting ausf√ºhren (Reusable Workflow)
  prerequisite-lint:
    uses: ./.github/workflows/lua-lint.yml
    secrets: inherit

  # 2. Voraussetzung: Tests ausf√ºhren (Reusable Workflow)
  prerequisite-test:
    uses: ./.github/workflows/test-release.yml
    secrets: inherit

  # 3. Eigentlicher Release (wartet auf Lint und Test)
  release:
    runs-on: lunexor
    needs: [prerequisite-lint, prerequisite-test]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Erstelle Release-Archiv mit Fixed Resource (exkludiere .git und .github)
      - name: Create archive of resource
        run: |
          ARCHIVE_NAME="mm_megaphone-${{ github.ref_name }}.tar.gz"
          
          echo "Creating release archive: $ARCHIVE_NAME"
          tar --exclude='.git*' --exclude='.github' -czf "$ARCHIVE_NAME" .
          
          # Zeige Archiv-Details
          echo "Archive created successfully:"
          ls -lh "$ARCHIVE_NAME"
          
          # Speichere Archivname f√ºr sp√§tere Steps
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV

      # Erstelle GitHub Release mit Archiv als Asset
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2.4.2
        with:
          files: ${{ env.ARCHIVE_NAME }}
          body: |
            Release for ${{ github.ref_name }}
          draft: false
          prerelease: false

      # --- Notifications ---

      # Discord Notification: Erstelle Payload als Datei (verhindert Escaping-Probleme)
      - name: Prepare Discord Payload
        if: always()
        id: discord_payload
        run: |
          STATUS="${{ job.status }}"
          RELEASE_URL="${{ steps.create_release.outputs.url }}"
          
          # Setze Farbe, Titel und Beschreibung basierend auf Status
          if [ "$STATUS" == "success" ]; then
            COLOR=3066993  # Gr√ºn
            TITLE="üéâ Release Ver√∂ffentlicht: ${{ github.ref_name }}"
            DESC="**‚úÖ Erfolgreich!** Bestanden (Lint & Test). Release erfolgreich erstellt."
            # Fallback zur Release-Seite, falls URL nicht verf√ºgbar
            if [ -z "$RELEASE_URL" ]; then
              RELEASE_URL="${{ github.server_url }}/${{ github.repository }}/releases"
            fi
          else
            COLOR=15158332  # Rot
            TITLE="‚ùå Release fehlgeschlagen"
            DESC="**‚ö†Ô∏è ACHTUNG:** Release-Erstellung ist fehlgeschlagen!"
            RELEASE_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          fi
          
          # Erstelle JSON Payload in tempor√§rer Datei
          cat <<EOF > payload.json
          {
            "username": "MM Megaphone CI/CD",
            "avatar_url": "https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg",
            "embeds": [{
              "title": "$TITLE",
              "description": "$DESC",
              "color": $COLOR,
              "fields": [
                { "name": "üè∑Ô∏è Version", "value": "\\`${{ github.ref_name }}\\`", "inline": true },
                { "name": "üì¶ Archiv", "value": "\\`${{ env.ARCHIVE_NAME }}\\`", "inline": true },
                { "name": "üîó Release", "value": "[Download]($RELEASE_URL)", "inline": true }
              ],
              "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
            }]
          }
          EOF

      - name: Notify Discord
        if: always()
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          curl -s -F "payload_json=$(cat payload.json)" "$DISCORD_WEBHOOK"

      - name: Notify Telegram
        if: always()
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_API_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          STATUS="${{ job.status }}"
          RELEASE_URL="${{ steps.create_release.outputs.url }}"
          
          # Setze Emoji basierend auf Status
          if [ "$STATUS" == "success" ]; then
            EMOJI="üéâ"
            STATUS_TEXT="erfolgreich"
            # Fallback zur Release-Seite
            if [ -z "$RELEASE_URL" ]; then
              RELEASE_URL="${{ github.server_url }}/${{ github.repository }}/releases"
            fi
          else
            EMOJI="‚ùå"
            STATUS_TEXT="fehlgeschlagen"
            RELEASE_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          fi
          
          # Erstelle Nachricht (URL-encoded f√ºr Telegram API)
          MESSAGE="$EMOJI *Release $STATUS_TEXT*%0A%0A"
          MESSAGE+="*Version:* \`${{ github.ref_name }}\`%0A"
          MESSAGE+="*Repo:* ${{ github.repository }}%0A%0A"
          MESSAGE+="‚úÖ *Lint:* Bestanden%0A"
          MESSAGE+="‚úÖ *Test:* Bestanden%0A"
          
          if [ "$STATUS" == "success" ]; then
            MESSAGE+="‚úÖ *Release:* Erstellt%0A%0A"
            MESSAGE+="[üöÄ Release ansehen]($RELEASE_URL)"
          else
            MESSAGE+="‚ùå *Release:* Fehlgeschlagen%0A%0A"
            MESSAGE+="[üîç Logs ansehen]($RELEASE_URL)"
          fi
          
          # Sende via Telegram Bot API
          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
               -d "chat_id=${TELEGRAM_CHAT_ID}" \
               -d "text=${MESSAGE}" \
               -d "parse_mode=Markdown" \
               -d "disable_web_page_preview=true"
